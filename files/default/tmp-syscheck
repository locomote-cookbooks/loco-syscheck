#!/usr/bin/env syscheck

check_system

failed_email_blacklist="@ssdf.com"

PAT_NON_EXISTENT_USER="(The email account that you tried to reach does not exist|No such user)"

# TODO - DRY up this function on next change!
check_failed_emails() {
  MAIL_LOGFILE=${MAIL_LOGFILE:-/var/log/maillog}

  local emails_sent=$(
    sudo grep status=sent $MAIL_LOGFILE |
    sed 's/.* to=<//g' | sed 's/>,.*//g'
  )
  local emails_failed=$(
    sudo grep status= $MAIL_LOGFILE |
    egrep -v "$PAT_NON_EXISTENT_USER" |
    grep -v sent | sed 's/.* to=<//g' | sed 's/>,.*//g' |
    grep -v root | grep -v localhost | grep -v locomotetmp |
    grep -v -E $failed_email_blacklist
  )
  local emails_failed_non_existent=$(
    sudo grep status= $MAIL_LOGFILE |
    egrep "$PAT_NON_EXISTENT_USER" |
    grep -v sent | sed 's/.* to=<//g' | sed 's/>,.*//g' |
    grep -v root | grep -v localhost | grep -v locomotetmp |
    grep -v -E $failed_email_blacklist
  )

  local number_of_sent_emails=$(        [  "$emails_sent"   ] && (echo "$emails_sent"   | wc -l | tr -d ' ') || echo 0)
  local number_of_failed_emails=$(      [  "$emails_failed" ] && (echo "$emails_failed" | wc -l | tr -d ' ') || echo 0)
  local number_of_failed_non_existent=$([  "$emails_failed_non_existent" ] && (echo "$emails_failed_non_existent" | wc -l | tr -d ' ') || echo 0)

  run echo "$number_of_sent_emails email(s) sent to : $(            echo "$emails_sent"   | sort -u | xargs)"
  run echo "$number_of_failed_emails email(s) failed to send to : $(echo "$emails_failed" | sort -u | xargs)"
  run echo "$number_of_failed_non_existent email(s) failed to send to non existent users: $(echo "$emails_failed_non_existent" | sort -u | xargs)"

  assert equal $number_of_failed_emails 0
}

not_on_systest() {
  [ $(hostname) != "tmp-systest" ]
}

my_process_pids() { local process=$1
  pgrep -u $USER $process
}


#########

check_god() {
  describe 'god'
    its_process_count 'god' 1
  end_describe
}

check_unicorn() {
  describe 'unicorn'
    its_process_count 'unicorn_rails master' ${UNICORN_MASTER_PROCESS_COUNT:=2}
    its_process_count 'unicorn_rails worker' ${UNICORN_WORKER_PROCESS_COUNT:=8}
  end_describe
}

check_ruby_version() {
  describe 'ruby_version'
    local ruby_version=${RUBY_VERSION:-ruby-2.0.0-p195}
    it "all ruby processes should use $ruby_version"
      all=true
      for p in $(my_process_pids ruby); do
        exe_ruby_version=$(ls -l /proc/$p/exe)
        run echo $exe_ruby_version
        all=$([[ $exe_ruby_version =~ $ruby_version ]] && $all && echo true || echo false)
      done
      assert test $all
  end_describe
}

check_nginx() {
  describe 'nginx'
    its_process_count 'nginx: master process' ${NGINX_MASTER_PROCESS_COUNT:=1}
    its_process_count 'nginx: worker process' ${NGINX_WORKER_PROCESS_COUNT:=$(cmd_for number_of_cores)}
  end_describe
}

check_redis() {
  describe 'redis'
    its_process_count 'redis-server' ${REDIS_PROCESS_COUNT:=1}
  end_describe
}

check_resque() {
  describe 'resque'
    its_process_count 'resque' ${RESQUE_PROCESS_COUNT:=4}
  end_describe
}

check_postfix() {
  describe 'postfix'
    its_process_count 'postfix/master' ${POSTFIX_PROCESS_COUNT:=1}

    if not_on_systest; then
      it "should have the correct hostname in the (chef generated) postfix config file"
        myhostname=`grep ^myhostname /etc/postfix/main.cf | sed 's/^myhostname = //'`
        fqdn=`hostname --fqdn`
        run echo "=> myhostname: $myhostname (fqdn: $fqdn)"
        assert equal $myhostname $fqdn

      it 'should not have any failed emails'
        check_failed_emails
    fi

  end_describe
}


DEFAULT_TMP_CHECKS="god unicorn ruby_version nginx redis resque postfix"
check_tmp() {
  for c in $@; do
    func="check_${c}"
    type $func 2> /dev/null | grep -q 'function' && $func
  done
}

check_tmp ${TMP_CHECKS:-$DEFAULT_TMP_CHECKS}
